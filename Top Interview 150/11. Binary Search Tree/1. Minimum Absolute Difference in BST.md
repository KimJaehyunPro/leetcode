https://leetcode.com/problems/minimum-absolute-difference-in-bst/description/?envType=study-plan-v2&envId=top-interview-150
# Problem: 530. Minimum Absolute Difference in BST

**Difficulty:** Easy  
**Topics:** Tree, Depth-First Search, Binary Search Tree

**Problem Statement:**

Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.

**Example 1:**

- **Input:** `root = [4,2,6,1,3]`
- **Output:** `1`

**Example 2:**

- **Input:** `root = [1,0,48,null,null,12,49]`
- **Output:** `1`

**Constraints:**

- The number of nodes in the tree is in the range `[2, 10^4]`.
- `0 <= Node.val <= 10^5`

> **Note:** This question is the same as [783: Minimum Distance Between BST Nodes](https://leetcode.com/problems/minimum-distance-between-bst-nodes/).

**Seen this question in a real interview before?**

- 1/5 - Yes
- 1/5 - No

---

**Accepted:** 413.9K  
**Submissions:** 707.7K  
**Acceptance Rate:** 58.5%

---

### My solution:

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        vals = []

        # Add all vals
        def find_all_vals(node):
            vals.append(node.val)
            if node.left:
                find_all_vals(node.left)
            if node.right:
                find_all_vals(node.right)

        find_all_vals(root)

        # Sort the vals in ascending order
        vals.sort()

        # Get the minimum difference
        minimum_difference = float('inf')

        # Check the difference between ith and (i + 1)th val
        for i in range(len(vals) - 1):
            difference = abs(vals[i] - vals[i + 1])
            minimum_difference = min(minimum_difference, difference)

        return minimum_difference
```

---

### Better Solution:

```python
from collections import deque

class Solution:
    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        def inorder(node, result):
            if node:
                inorder(node.left, result)
                result.append(node.val)
                inorder(node.right, result)
            return result

        res = inorder(root, [])
        n = len(res)
        if n == 1:
            return res[0]

        r = float('inf')
        for i in range(1, n):
            r = min(r, res[i] - res[i - 1])

        return r
```

---

**Performance:**

- **Runtime:** 46 ms (Beats 67.91%)
- **Memory:** 18.44 MB (Beats 15.16%)

---

**Related Topics:**
- Tree
- Depth-First Search
- Breadth-First Search
- Binary Search Tree
- Binary Tree

**Related Companies:**

---

**Similar Questions:**

- [88. Merge Sorted Array (Easy)](https://leetcode.com/problems/merge-sorted-array/)
- [27. Remove Element (Easy)](https://leetcode.com/problems/remove-element/)
- [26. Remove Duplicates from Sorted Array (Easy)](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)
- [80. Remove Duplicates from Sorted Array II (Medium)](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)
- [530. Minimum Absolute Difference in BST (Easy)](https://leetcode.com/problems/minimum-absolute-difference-in-bst/)

---

The "Better Solution" provided for the problem is considered better primarily due to the following reasons:

### 1. **Efficiency (Time Complexity):**
   - **Original Solution:** 
     - This approach first collects all the node values in a list, sorts them, and then calculates the minimum difference. Sorting has a time complexity of \(O(N \log N)\), where \(N\) is the number of nodes in the BST.
     - The traversal of the tree to gather the values has a time complexity of \(O(N)\).
     - Overall time complexity: \(O(N \log N)\).
   
   - **Better Solution:**
     - This approach directly computes the minimum difference while performing an in-order traversal of the BST, which inherently provides the sorted order of values.
     - The in-order traversal has a time complexity of \(O(N)\), and since there's no separate sorting step, the overall time complexity remains \(O(N)\).

### 2. **Memory Usage:**
   - **Original Solution:** 
     - Stores all node values in a list, which requires \(O(N)\) additional space.
   
   - **Better Solution:**
     - The better solution also requires \(O(N)\) space to store the results of the in-order traversal, but it can be optimized to \(O(H)\) where \(H\) is the height of the tree if the in-order traversal is done iteratively and without storing all node values (though this version still stores all values for simplicity).

### 3. **Optimal Use of BST Properties:**
   - **Original Solution:**
     - It doesn't fully leverage the properties of a BST (that an in-order traversal yields sorted values) since it collects and then explicitly sorts the values.
   
   - **Better Solution:**
     - Takes full advantage of the BST properties by directly computing the minimum difference during the in-order traversal, which inherently processes the values in sorted order. This eliminates the need for additional sorting.

### 4. **Readability and Maintainability:**
   - **Original Solution:**
     - The logic is split into multiple parts: collecting values, sorting, and then finding the minimum difference. This separation makes the code longer and slightly harder to follow.
   
   - **Better Solution:**
     - The better solution is more streamlined. The logic for finding the minimum difference is integrated into the traversal process itself, making the code more concise and easier to understand.

### Summary:
The "Better Solution" is more efficient in terms of time complexity, makes better use of the BST properties, and is more concise and easier to maintain. This makes it superior, especially for larger input sizes where the efficiency gain from avoiding sorting can be significant.