https://leetcode.com/problems/valid-parentheses/solutions/5139933/video-2-ways-to-solve-this-question/?envType=study-plan-v2&envId=top-interview-150
### Problem: Valid Parentheses

#### Problem Description:
Given a string `s` containing just the characters `'(', ')', '{', '}', '[' and ']'`, determine if the input string is valid.

An input string is valid if:
1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.
3. Every close bracket has a corresponding open bracket of the same type.

#### Constraints:
- `1 <= s.length <= 10^4`
- `s` consists of parentheses only `'()[]{}'`.

#### Examples:

**Example 1:**
- **Input:** `s = "()"`  
- **Output:** `true`

**Example 2:**
- **Input:** `s = "()[]{}"`  
- **Output:** `true`

**Example 3:**
- **Input:** `s = "(]"`  
- **Output:** `false`

**Example 4:**
- **Input:** `s = "([])"`  
- **Output:** `true`

---

### Your Solution:

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []

        for parentheses in s:
            if parentheses in '({[':
                stack.append(parentheses)

            elif parentheses in ')}]':
                if len(stack) == 0:
                    return False
                top_parentheses = stack[-1]
                if (top_parentheses == '(' and parentheses != ')') or \
                   (top_parentheses == '{' and parentheses != '}') or \
                   (top_parentheses == '[' and parentheses != ']'):
                    return False
                
                stack.pop()

        return len(stack) == 0
```

### Explanation:
1. **Initialization**: You initialize an empty `stack` to keep track of open brackets.
2. **Iteration**: You iterate over each character in the string `s`.
   - If the character is an open bracket (`'('`, `'{'`, `'['`), you push it onto the stack.
   - If the character is a close bracket (`')'`, `'}'`, `']'`):
     - Check if the stack is empty; if so, return `False`.
     - Otherwise, check if the top element of the stack is the corresponding open bracket. If not, return `False`.
     - If the brackets match, pop the top of the stack.
3. **Final Check**: After processing all characters, if the stack is empty, return `True`; otherwise, return `False`.

---

### Better Solution:

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        mapping = {")": "(", "}": "{", "]": "["}

        for char in s:
            if char in mapping.values():
                stack.append(char)
            elif char in mapping.keys():
                if not stack or mapping[char] != stack.pop():
                    return False
        
        return not stack
```

### Explanation of the Better Solution:
1. **Mapping Dictionary**: This solution uses a dictionary `mapping` to store the pairs of matching brackets. The keys are closing brackets, and the values are the corresponding opening brackets.
   
2. **Simplified Logic**:
   - **Push Open Brackets**: If the character is an open bracket (found in `mapping.values()`), it is pushed onto the stack.
   - **Match Close Brackets**: If the character is a close bracket (found in `mapping.keys()`), the stack is checked to ensure it is not empty and that the top of the stack matches the corresponding open bracket using the `mapping` dictionary. If either condition fails, `False` is returned.
   
3. **Final Check**: After processing all characters, return `True` if the stack is empty, indicating all open brackets were properly closed. Otherwise, return `False`.

### Why the Better Solution is Better:
1. **Cleaner and More Readable**: The use of a `mapping` dictionary simplifies the logic for matching brackets, making the code easier to read and understand.
2. **Reduced Conditionals**: The original solution has multiple `if-elif` conditions to check for matching brackets. The better solution reduces this to a single dictionary lookup and comparison, which is more efficient and concise.
3. **Scalability**: The solution is more adaptable. If additional types of brackets were introduced, you would only need to update the `mapping` dictionary without modifying the core logic.

### Summary:
- The **original solution** works well but uses more conditionals, making it slightly harder to maintain and less clean.
- The **better solution** streamlines the logic by using a dictionary, which simplifies bracket matching and makes the code more readable and maintainable. It also eliminates unnecessary checks, making it the preferred approach for solving this problem.