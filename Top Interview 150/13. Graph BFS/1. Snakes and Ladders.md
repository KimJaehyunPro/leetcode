[Snakes and Ladders](https://leetcode.com/problems/snakes-and-ladders/description/?envType=study-plan-v2&envId=top-interview-150)

## Problem: Snakes and Ladders

You are given an `n x n` integer matrix `board` where the cells are labeled from `1` to `n^2` in a Boustrophedon style starting from the bottom left of the board (i.e., `board[n - 1][0]`) and alternating direction each row.

You start on square `1` of the board. In each move, starting from square `curr`, you do the following:

- Choose a destination square `next` with a label in the range `[curr + 1, min(curr + 6, n^2)]`. This choice simulates the result of a standard 6-sided die roll: i.e., there are always at most 6 destinations, regardless of the size of the board.
- If `next` has a snake or ladder, you must move to the destination of that snake or ladder. Otherwise, you move to `next`.
- The game ends when you reach the square `n^2`.

A board square on row `r` and column `c` has a snake or ladder if `board[r][c] != -1`. The destination of that snake or ladder is `board[r][c]`. Squares `1` and `n^2` are not the starting points of any snake or ladder.

**Note**: You only take a snake or ladder at most once per move. If the destination of a snake or ladder is the start of another snake or ladder, you do not follow the subsequent snake or ladder.

### Example 1:

**Input**:
```python
board = [
  [-1,-1,-1,-1,-1,-1],
  [-1,-1,-1,-1,-1,-1],
  [-1,-1,-1,-1,-1,-1],
  [-1,35,-1,-1,13,-1],
  [-1,-1,-1,-1,-1,-1],
  [-1,15,-1,-1,-1,-1]
]
```

![alt text](1.%20Snakes%20and%20Ladders-1.png)

**Output**: `4`

**Explanation**:
- In the beginning, you start at square `1` (at row `5`, column `0`).
- You decide to move to square `2` and must take the ladder to square `15`.
- You then decide to move to square `17` and must take the snake to square `13`.
- You then decide to move to square `14` and must take the ladder to square `35`.
- You then decide to move to square `36`, ending the game.
- This is the lowest possible number of moves to reach the last square, so return `4`.

### Example 2:

**Input**:
```python
board = [[-1,-1],[-1,3]]
```

**Output**: `1`

### Constraints:

- `n == board.length == board[i].length`
- `2 <= n <= 20`
- `board[i][j]` is either `-1` or in the range `[1, n^2]`.
- The squares labeled `1` and `n^2` are not the starting points of any snake or ladder.

---

## Solution (I couldn't solve it )

```python
from collections import deque
from typing import List

class Solution:
    def snakesAndLadders(self, board: List[List[int]]) -> int:
        n = len(board)  # Size of the board (n x n)
        flattened_board = []  # To store the flattened version of the board in 1D
        board_positions = []  # To store the actual positions after considering snakes and ladders
        
        # Flatten the board while maintaining the Boustrophedon order
        for i in range(n):
            if i % 2 == 1:
                # Reverse the row if it's an odd-numbered row (from the bottom)
                board[n - i - 1].reverse()
            # Add the row to the flattened board
            flattened_board += board[n - i - 1]
        
        # Create the board_positions array that maps the flattened board to the game positions
        for i in range(n ** 2):
            if flattened_board[i] != -1:
                # If there's a snake or ladder, move to the destination square
                board_positions.append(flattened_board[i])
            else:
                # If no snake or ladder, stay on the current square
                board_positions.append(i + 1)
        
        # Print the intermediate states for debugging purposes
        print(f"flattened_board: {flattened_board}")
        print(f"board_positions: {board_positions}")

        # Initialize the BFS queue with the starting position (square 1)
        queue = [board_positions[0]]
        visited = set()  # Set to track visited positions
        visited.add(board_positions[0])
        move_count = 0  # Counter for the number of moves taken
        last_processed = board_positions[0]  # To track the last processed position in the current level of BFS

        # BFS loop to explore the board
        while queue:
            print(f"queue: {queue}")
            current_pos = queue.pop(0)  # Get the current position from the queue
            # Calculate the possible next positions from current_pos (up to 6 moves ahead)
            next_positions = board_positions[current_pos: current_pos + 6]
            
            # Check if the last square (n^2) is within the next possible positions
            if n ** 2 in next_positions:
                return move_count + 1  # If yes, return the number of moves taken to reach it
            
            # Process each possible next position
            for pos in next_positions:
                if pos not in visited:  # If the position hasn't been visited yet
                    queue.append(pos)  # Add it to the BFS queue
                    visited.add(pos)  # Mark it as visited
            
            # If we've processed all possible moves at the current level, increment the move count
            if last_processed == current_pos and queue:
                last_processed = queue[-1]  # Update the last processed position
                move_count += 1  # Increment the move count since we're moving to a new level in BFS

        return -1  # If we exhaust the queue without reaching the last square, return -1 (unreachable)
```

## How the Solution Works

### Step 1: Flattening the Board
- The first task is to convert the `n x n` board into a 1D array (`flattened_board`) that respects the Boustrophedon pattern. This involves reversing every other row as you move up the board from bottom to top.

### Step 2: Mapping Positions
- After flattening the board, we create an array (`board_positions`) that maps each square to its final destination. If a square contains a ladder or snake, the corresponding index in `board_positions` is the destination of that ladder or snake. If there's no ladder or snake, the position maps to itself.

### Step 3: Breadth-First Search (BFS)
- BFS is used to explore the board starting from square `1`. The BFS queue keeps track of all possible positions that can be reached with the minimum number of moves.
- For each position, the algorithm considers up to 6 moves ahead (simulating a 6-sided die roll). If moving to any of these positions lands on a ladder or snake, the BFS queue is updated with the destination of that ladder or snake.
- The `visited` set ensures that each square is processed only once, avoiding infinite loops and redundant calculations.

### Step 4: Checking for the Goal
- If at any point the BFS queue reaches the last square (`n^2`), the algorithm returns the number of moves taken to get there. If the BFS queue is exhausted without reaching the last square, the algorithm returns `-1`, indicating that the goal is unreachable.

### Conclusion:
This approach efficiently finds the minimum number of moves required to reach the last square by considering all possible moves from each square in a breadth-first manner, taking advantage of any shortcuts provided by ladders and avoiding pitfalls caused by snakes.